{
  "url": "https://x6.antv.antgroup.com/tutorial/basic/events",
  "metadata": {
    "title": "事件 | X6 图编辑引擎",
    "description": "",
    "keywords": [],
    "author": "",
    "publish_date": "",
    "domain": "x6.antv.antgroup.com"
  },
  "content": "# 事件\n\n#### 在本章节中主要介绍事件相关的知识,通过阅读你可以了解到\n\n  * 可以监听哪些类别事件\n  * 如何监听事件\n\n\n\n## 视图交互事件\n\n通过鼠标、键盘或者各种可交互的组件与应用产生交互时触发的事件。\n\n### 鼠标事件\n\n事件| cell 节点/边| node 节点| port 连接桩| edge 边| blank 画布空白区域  \n---|---|---|---|---|---  \n单击| `cell:click`| `node:click`| `node:port:click`| `edge:click`| `blank:click`  \n双击| `cell:dblclick`| `node:dblclick`| `node:port:dblclick`| `edge:dblclick`| `blank:dblclick`  \n右键| `cell:contextmenu`| `node:contextmenu`| `node:port:contextmenu`| `edge:contextmenu`| `blank:contextmenu`  \n鼠标按下| `cell:mousedown`| `node:mousedown`| `node:port:mousedown`| `edge:mousedown`| `blank:mousedown`  \n移动鼠标| `cell:mousemove`| `node:mousemove`| `node:port:mousemove`| `edge:mousemove`| `blank:mousemove`  \n鼠标抬起| `cell:mouseup`| `node:mouseup`| `node:port:mouseup`| `edge:mouseup`| `blank:mouseup`  \n鼠标滚轮| `cell:mousewheel`| `node:mousewheel`| -| `edge:mousewheel`| `blank:mousewheel`  \n鼠标进入| `cell:mouseenter`| `node:mouseenter`| `node:port:mouseenter`| `edge:mouseenter`| `graph:mouseenter`  \n鼠标离开| `cell:mouseleave`| `node:mouseleave`| `node:port:mouseleave`| `edge:mouseleave`| `graph:mouseleave`  \n  \n#### 注意\n\n需要注意的是，这里的 `mousemove` 事件和通常的鼠标移动事件有所区别，它需要在鼠标按下后移动鼠标才能触发。\n\n除了 `mouseenter` 和 `mouseleave` 外，事件回调函数的参数都包含鼠标相对于画布的位置 `x`、`y` 和鼠标事件对象 `e` 等参数。\n    \n    \n    graph.on('cell:click',({ e, x, y, cell, view })=>{})\n    \n    graph.on('node:click',({ e, x, y, node, view })=>{})\n    \n    graph.on('edge:click',({ e, x, y, edge, view })=>{})\n    \n    graph.on('blank:click',({ e, x, y })=>{})\n    \n    graph.on('cell:mouseenter',({ e, cell, view })=>{})\n    \n    graph.on('node:mouseenter',({ e, node, view })=>{})\n    \n    graph.on('edge:mouseenter',({ e, edge, view })=>{})\n    \n    graph.on('graph:mouseenter',({ e })=>{})\n\n### 自定义点击事件\n\n我们可以在节点/边的 DOM 元素上添加自定义属性 `event` 或 `data-event` 来监听该元素的点击事件，例如：\n    \n    \n    node.attr({\n    \n    // 表示一个删除按钮，点击时删除该节点\n    \n      image:{\n    \n        event:'node:delete',\n    \n        xlinkHref:'trash.png',\n    \n        width:20,\n    \n        height:20,\n    \n    },\n    \n    })\n\n可以通过绑定的事件名 `node:delete` 或通用的 `cell:customevent`、`node:customevent`、`edge:customevent` 事件名来监听。\n    \n    \n    graph.on('node:delete',({ view, e })=>{\n    \n      e.stopPropagation()\n    \n      view.cell.remove()\n    \n    })\n    \n    graph.on('node:customevent',({ name, view, e })=>{\n    \n    if(name ==='node:delete'){\n    \n        e.stopPropagation()\n    \n        view.cell.remove()\n    \n    }\n    \n    })\n\nSourcexTargetx\n\n### 画布缩放/平移\n\n事件名| 回调参数| 说明  \n---|---|---  \n`scale`| `{ sx: number; sy: number; ox: number; oy: number }`| 缩放画布时触发，`sx` 和 `sy` 是缩放比例，`ox` 和 `oy` 是缩放中心。  \n`resize`| `{ width: number; height: number }`| 改变画布大小时触发，`width` 和 `height` 是画布大小。  \n`translate`| `{ tx: number; ty: number }`| 平移画布时触发，`tx` 和 `ty` 分别是 X 和 Y 轴的偏移量。  \n      \n    \n    graph.on('scale',({ sx, sy, ox, oy })=>{})\n    \n    graph.on('resize',({ width, height })=>{})\n    \n    graph.on('translate',({ tx, ty })=>{})\n\n### 节点或边平移\n\n事件名| 回调参数| 说明  \n---|---|---  \n`node:move`| `{ e: Dom.MouseDownEvent; x: number; y: number; node: Node; view: NodeView }`| 开始移动节点时触发。  \n`node:moving`| `{ e: Dom.MouseMoveEvent; x: number; y: number; node: Node; view: NodeView }`| 移动节点时触发。  \n`node:moved`| `{ e: Dom.MouseUpEvent; x: number; y: number; node: Node; view: NodeView }`| 移动节点后触发。  \n`edge:move`| `{ e: Dom.MouseDownEvent; x: number; y: number; node: Node; view: NodeView }`| 开始移动边时触发。  \n`edge:moving`| `{ e: Dom.MouseMoveEvent; x: number; y: number; node: Node; view: NodeView }`| 移动边时触发。  \n`edge:moved`| `{ e: Dom.MouseUpEvent; x: number; y: number; node: Node; view: NodeView }`| 移动边后触发。  \n  \n参数中的 `x` 和 `y` 是鼠标相对于画布的坐标。\n    \n    \n    graph.on('node:moved',({ e, x, y, node, view })=>{})\n\n### 节点嵌入\n\n事件名| 回调参数| 说明  \n---|---|---  \n`node:embed`| `{ e: Dom.MouseDownEvent; x: number; y: number; node: Node; view: NodeView, currentParent: Node }`| 开启嵌入，在开始拖动节点时触发。  \n`node:embedding`| `{ e: Dom.MouseMoveEvent; x: number; y: number; node: Node; view: NodeView, currentParent: Node, candidateParent: Node }`| 寻找目标节点过程中触发。  \n`node:embedded`| `{ e: Dom.MouseUpEvent; x: number; y: number; node: Node; view: NodeView, previousParent: Node, currentParent: Node }`| 完成节点嵌入后触发。  \n  \n### 边连接/取消连接\n\n当拖动边的起始/终止箭头将边连接到节点/边或者将边从节点/边上分离后触发 `edge:connected`，回调函数的参数如下。\n    \n    \n    interfaceArgs{\n    \n      e: Dom.MouseUpEvent // 鼠标事件对象\n    \n      edge: Edge // 边\n    \n      view: EdgeView // 边的视图\n    \n      isNew:boolean// 是否是新创建的边\n    \n      type: Edge.TerminalType // 操作的是起始箭头还是终止箭头（'source' | 'target'）\n    \n      previousCell?: Cell |null// 交互前连接到的节点/边\n    \n      previousView?: CellView |null// 交互前连接到的节点/边的视图\n    \n      previousPort?:string|null// 交互前连接到的连接桩 ID\n    \n      previousPoint?: Point.PointLike |null// 交互前连接到的点（将边的终端从空白处拖动到节点/边上时记录起始终端的位置）\n    \n      previousMagnet?: Element |null// 交互前连接到的元素\n    \n      currentCell?: Cell |null// 交互后连接到的节点/边\n    \n      currentView?: CellView |null// 交互后连接到的节点/边的视图\n    \n      currentPort?:string|null// 交互后连接到的连接桩 ID\n    \n      currentPoint?: Point.PointLike |null// 交互后连接到的点（将边的终端从节点/边上拖动到空白处时记录拖动后终端的位置）\n    \n      currentMagnet?: Element |null// 交互后连接到的元素\n    \n    }\n\n我们可以通过 `isNew` 来判断连线完成后，对应的边是否是新创建的边。比如从一个连接桩开始，创建了一条边并连接到另一个节点/连接桩，此时 `isNew` 就为 `true`。\n    \n    \n    graph.on('edge:connected',({ isNew, edge })=>{\n    \n    if(isNew){\n    \n    // 对新创建的边进行插入数据库等持久化操作\n    \n    }\n    \n    })\n\n特别注意的是，参数中的 `previous...` 是记录操作终端在连接/取消连接之前的状态，并不是指 `sourceCell`，在创建新边后获取 `sourceCell` 时不能使用 `previousCell`，正确的使用方式是：\n    \n    \n    graph.on('edge:connected',({ isNew, edge })=>{\n    \n    if(isNew){\n    \n    const source = edge.getSourceCell()\n    \n    }\n    \n    })\n\n## 节点/边\n\n### 添加/删除/修改\n\n当节点/边被添加到画布时，触发以下事件：\n\n  * `added`\n  * `cell:added`\n  * `node:added`（仅当 cell 是节点时才触发）\n  * `edge:added`（仅当 cell 是边时才触发）\n\n\n\n当节点/边被移除时，触发以下事件：\n\n  * `removed`\n  * `cell:removed`\n  * `node:removed`（仅当 cell 是节点时才触发）\n  * `edge:removed`（仅当 cell 是边时才触发）\n\n\n\n当节点/边发生任何改变时，触发以下事件：\n\n  * `changed`\n  * `cell:changed`\n  * `node:changed`（仅当 cell 是节点时才触发）\n  * `edge:changed`（仅当 cell 是边时才触发）\n\n\n\n可以在节点/边上监听：\n    \n    \n    cell.on('added',({ cell, index, options })=>{})\n    \n    cell.on('removed',({ cell, index, options })=>{})\n    \n    cell.on('changed',({ cell, options })=>{})\n\n或者在 Graph 上监听：\n    \n    \n    graph.on('cell:added',({ cell, index, options })=>{})\n    \n    graph.on('cell:removed',({ cell, index, options })=>{})\n    \n    graph.on('cell:changed',({ cell, options })=>{})\n    \n    graph.on('node:added',({ node, index, options })=>{})\n    \n    graph.on('node:removed',({ node, index, options })=>{})\n    \n    graph.on('node:changed',({ node, options })=>{})\n    \n    graph.on('edge:added',({ edge, index, options })=>{})\n    \n    graph.on('edge:removed',({ edge, index, options })=>{})\n    \n    graph.on('edge:changed',({ edge, options })=>{})\n\n### change:xxx\n\n当调用 `setXxx(val, options)` 和 `removeXxx(options)` 方法去改变节点/边的数据时，并且 `options.silent` 不为 `true` 时，都将触发对应的 `change` 事件，并触发节点/边重绘。例如：\n    \n    \n    cell.setZIndex(2)\n    \n    cell.setZIndex(2,{ silent:false})\n    \n    cell.setZIndex(2,{ anyKey:'anyValue'})\n\n将触发 Cell 上的以下事件：\n\n  * `change:*`\n  * `change:zIndex`\n\n\n\n和 Graph 上的以下事件：\n\n  * `cell:change:*`\n  * `node:change:*`（仅当 cell 是节点时才触发）\n  * `edge:change:*`（仅当 cell 是边时才触发）\n  * `cell:change:zIndex`\n  * `node:change:zIndex`（仅当 cell 是节点时才触发）\n  * `edge:change:zIndex`（仅当 cell 是边时才触发）\n\n\n\n可以在节点/边上监听：\n    \n    \n    // 当 cell 发生任何改变时都将被触发，可以通过 key 来确定改变项\n    \n    cell.on(\n    \n    'change:*',\n    \n    (args:{\n    \n        cell: Cell\n    \n        key:string// 通过 key 来确定改变项\n    \n        current:any// 当前值\n    \n        previous:any// 改变之前的值\n    \n        options:any// 透传的 options\n    \n    })=>{\n    \n    if(key ==='zIndex'){\n    \n    //\n    \n    }\n    \n    },\n    \n    )\n    \n    cell.on(\n    \n    'change:zIndex',\n    \n    (args:{\n    \n        cell: Cell\n    \n        current?:number// 当前值\n    \n        previous?:number// 改变之前的值\n    \n        options:any// 透传的 options\n    \n    })=>{},\n    \n    )\n\n或者在 Graph 上监听：\n    \n    \n    graph.on(\n    \n    'cell:change:zIndex',\n    \n    (args:{\n    \n        cell: Cell\n    \n        current?:number// 当前值\n    \n        previous?:number// 改变之前的值\n    \n        options:any// 透传的 options\n    \n    })=>{},\n    \n    )\n    \n    // 当 cell 为节点时触发\n    \n    graph.on(\n    \n    'node:change:zIndex',\n    \n    (args:{\n    \n        cell: Cell\n    \n        node: Node\n    \n        current?:number// 当前值\n    \n        previous?:number// 改变之前的值\n    \n        options:any// 透传的 options\n    \n    })=>{},\n    \n    )\n    \n    // 当 cell 为边时触发\n    \n    graph.on(\n    \n    'edge:change:zIndex',\n    \n    (args:{\n    \n        cell: Cell\n    \n        edge: Edge\n    \n        current?:number// 当前值\n    \n        previous?:number// 改变之前的值\n    \n        options:any// 透传的 options\n    \n    })=>{},\n    \n    )\n\n其他 `change` 事件如下列表，回调函数的参数与上面提到的 `change:zIndex` 的参数结构一致。\n\n  * Cell \n    * `change:*`\n    * `change:attrs`\n    * `change:zIndex`\n    * `change:markup`\n    * `change:visible`\n    * `change:parent`\n    * `change:children`\n    * `change:tools`\n    * `change:view`\n    * `change:data`\n  * Node \n    * `change:size`\n    * `change:angle`\n    * `change:position`\n    * `change:ports`\n    * `change:portMarkup`\n    * `change:portLabelMarkup`\n    * `change:portContainerMarkup`\n    * `ports:added`\n    * `ports:removed`\n  * Edge \n    * `change:source`\n    * `change:target`\n    * `change:terminal`\n    * `change:router`\n    * `change:connector`\n    * `change:vertices`\n    * `change:labels`\n    * `change:defaultLabel`\n    * `vertexs:added`\n    * `vertexs:removed`\n    * `labels:added`\n    * `labels:removed`\n\n\n\n除了上述这些内置的 Key，我们也支持监听自定义的 Key，例如\n    \n    \n    cell.on('change:custom',({ cell, current, previous, options })=>{\n    \n    console.log(current)\n    \n    })\n\n当通过 `cell.prop('custom', 'any data')` 方法修改 `custom` 属性的值时将触发 `change:custom` 事件。\n\n### 动画\n\n  * `transition:start` 动画开始时触发\n  * `transition:progress` 动画过程中触发\n  * `transition:complete` 动画完成时触发\n  * `transition:stop` 动画被停止时触发\n  * `transition:finish` 动画完成或被停止时触发\n\n\n    \n    \n    cell.on('transition:start',(args: Animation.CallbackArgs)=>{})\n    \n    cell.on('transition:progress',(args: Animation.ProgressArgs)=>{})\n    \n    cell.on('transition:complete',(args: Animation.CallbackArgs)=>{})\n    \n    cell.on('transition:stop',(args: Animation.StopArgs)=>{})\n    \n    cell.on('transition:finish',(args: Animation.CallbackArgs)=>{})\n    \n    graph.on('cell:transition:start',(args: Animation.CallbackArgs)=>{})\n    \n    graph.on('cell:transition:progress',(args: Animation.ProgressArgs)=>{})\n    \n    graph.on('cell:transition:complete',(args: Animation.CallbackArgs)=>{})\n    \n    graph.on('cell:transition:stop',(args: Animation.StopArgs)=>{})\n    \n    graph.on('cell:transition:finish',(args: Animation.CallbackArgs)=>{})\n    \n    graph.on('node:transition:start',(args: Animation.CallbackArgs)=>{})\n    \n    graph.on('node:transition:progress',(args: Animation.ProgressArgs)=>{})\n    \n    graph.on('node:transition:complete',(args: Animation.CallbackArgs)=>{})\n    \n    graph.on('node:transition:stop',(args: Animation.StopArgs)=>{})\n    \n    graph.on('node:transition:finish',(args: Animation.CallbackArgs)=>{})\n    \n    graph.on('edge:transition:start',(args: Animation.CallbackArgs)=>{})\n    \n    graph.on('edge:transition:progress',(args: Animation.ProgressArgs)=>{})\n    \n    graph.on('edge:transition:complete',(args: Animation.CallbackArgs)=>{})\n    \n    graph.on('edge:transition:stop',(args: Animation.StopArgs)=>{})\n    \n    graph.on('edge:transition:finish',(args: Animation.CallbackArgs)=>{})\n\n## 视图\n\n由于 X6 实现了异步的渲染调度算法，所以节点的添加不一定意味着挂载到画布上。节点在被挂载到画布时以及从画布上卸载时会分别触发单独的事件。\n\n事件名| 回调参数| 说明  \n---|---|---  \n`view:mounted`| `{ view: CellView }`| 节点被挂载到画布上时触发。  \n`view:unmounted`| `{ view: CellView }`| 节点从画布上卸载时触发。  \n      \n    \n    graph.on('view:mounted',({ view })=>{})\n    \n    graph.on('view:unmounted',({ view })=>{})\n\n大家还有经常需要在调用 `fromJSON` 或者 `resetCells` 后监听画布完成渲染事件，这时候可以使用 `render:done` 事件来监听 (2.15.1 版本新增)。\n    \n    \n    graph.on('render:done',()=>{\n    \n    // pass\n    \n    })\n    \n    graph.fromJSON([...])\n\n文档贡献者\n\n\n\n\n上一篇\n\n交互\n\n下一篇\n\n数据\n"
}