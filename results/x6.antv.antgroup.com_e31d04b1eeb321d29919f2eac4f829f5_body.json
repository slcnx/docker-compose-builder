{
  "url": "https://x6.antv.antgroup.com/api/registry/node-tool#node-editor",
  "metadata": {
    "title": "节点工具 | X6 图编辑引擎",
    "description": "",
    "keywords": [],
    "author": "",
    "publish_date": "",
    "domain": "x6.antv.antgroup.com"
  },
  "content": "# 节点工具\n\n节点小工具是一些渲染在节点上的一些小组件，这些小工具通常都附带一些交互功能，如删除按钮，点击按钮时删除对应的节点。我们可以根据下面的一些场景来添加或删除小工具。\n    \n    \n    // 创建节点时添加小工具\n    \n    graph.addNode({\n    \n    ...,\n    \n      tools:[\n    \n    {\n    \n          name:'button-remove',\n    \n          args:{ x:10, y:10},\n    \n    },\n    \n    ],\n    \n    })\n    \n    // 创建节点后添加小工具\n    \n    node.addTools([\n    \n    {\n    \n        name:'button-remove',\n    \n        args:{ x:10, y:10},\n    \n    },\n    \n    ])\n    \n    // 删除工具\n    \n    graph.on(\"node:mouseleave\",({ node })=>{\n    \n    if(node.hasTool(\"button-remove\")){\n    \n        node.removeTool(\"button-remove\");\n    \n    }\n    \n    });\n\n在 X6 中默认提供了以下几个用于节点的小工具：\n\n  * [button](https://x6.antv.antgroup.com/api/registry/node-tool#button) 在指定位置处渲染一个按钮，支持自定义按钮的点击交互。\n  * [button-remove](https://x6.antv.antgroup.com/api/registry/node-tool#button-remove) 在指定的位置处，渲染一个删除按钮，点击时删除对应的节点。\n  * [boundary](https://x6.antv.antgroup.com/api/registry/node-tool#boundary) 根据节点的包围盒渲染一个包围节点的矩形。注意，该工具仅仅渲染一个矩形，不带任何交互。\n  * [node-editor](https://x6.antv.antgroup.com/api/registry/node-tool#node-editor) 提供节点文本编辑功能。\n\n\n\n## 内置工具\n\n### button\n\n在指定位置处渲染一个按钮，支持自定义按钮的点击交互。配置如下：\n\n参数名| 类型| 默认值| 说明  \n---|---|---|---  \nx| number | string| `0`| 相对于节点的左上角 X 轴的坐标，小数和百分比表示相对位置。  \ny| number | string| `0`| 相对于节点的左上角 Y 轴的坐标，小数和百分比表示相对位置。  \noffset| number | `{ x: number, y: number }`| `0`| 在 `x` 和 `y` 基础上的偏移量。  \nrotate| boolean| -| 是否跟随节点旋转。  \nuseCellGeometry| boolean| `true`| 是否使用几何计算的方式来计算元素包围盒，开启后会有性能上的提升，如果出现计算准度问题，请将它设置为 `false`。  \nmarkup| Markup.JSONMarkup| -| 渲染按钮的 Markup 定义。  \nonClick| `(args: {e: Dom.MouseDownEvent, cell: Cell, view: CellView }) => void`| -| 点击按钮的回调函数。  \n      \n    \n    // 鼠标 Hover 时添加按钮\n    \n    graph.on('node:mouseenter',({ node })=>{\n    \n      node.addTools({\n    \n        name:'button',\n    \n        args:{\n    \n          markup:...,\n    \n          x:0,\n    \n          y:0,\n    \n          offset:{ x:18, y:18},\n    \n    onClick({ view }){...},\n    \n    },\n    \n    })\n    \n    })\n    \n    // 鼠标移开时删除按钮\n    \n    graph.on('node:mouseleave',({ node })=>{\n    \n       node.removeTools()// 删除所有的工具\n    \n    })\n\nsourcetargetBtn A\n\n### button-remove\n\n在指定的位置处，渲染一个删除按钮，点击时删除对应的节点。它是上面 `button` 工具的一个特例，所以支持 `button` 的所有配置。\n    \n    \n    const source = graph.addNode({\n    \n    ...,\n    \n    // 添加一个始终显示的删除按钮\n    \n      tools:[\n    \n    {\n    \n          name:'button-remove',\n    \n          args:{\n    \n            x:'100%',\n    \n            y:0,\n    \n            offset:{ x:-10, y:10},\n    \n    },\n    \n    },\n    \n    ],\n    \n    })\n\nsourcetarget\n\n### boundary\n\n根据节点的包围盒渲染一个包围节点的矩形。注意，该工具仅仅渲染一个矩形，不带任何交互。配置如下：\n\n参数名| 类型| 默认值| 说明  \n---|---|---|---  \ntagName| string| `rect`| 使用何种图形渲染。  \nrotate| boolean| -| 图形是否跟随节点旋转。  \npadding| SideOptions| `10`| 边距。  \nattrs| KeyValue| `object`| 图形属性。  \nuseCellGeometry| boolean| `true`| 是否使用几何计算的方式来计算元素包围盒，开启后会有性能上的提升，如果出现计算准度问题，请将它设置为 `false`。  \n  \n其中 `attrs` 的默认值(默认样式)为：\n    \n    \n    {\n    \n      fill:'none',\n    \n      stroke:'#333',\n    \n    'stroke-width':0.5,\n    \n    'stroke-dasharray':'5, 5',\n    \n    'pointer-events':'none',\n    \n    }\n\n`SideOptions` 的类型定义如下：\n    \n    \n    typeSideOptions=\n    \n    |number\n    \n    |{\n    \n          vertical?:number\n    \n          horizontal?:number\n    \n          left?:number\n    \n          top?:number\n    \n          right?:number\n    \n          bottom?:number\n    \n    }\n\n工具使用方式如下：\n    \n    \n    const source = graph.addNode({\n    \n    ...,\n    \n      tools:[\n    \n    {\n    \n          name:'boundary',\n    \n          args:{\n    \n            padding:5,\n    \n            attrs:{\n    \n              fill:'#7c68fc',\n    \n              stroke:'#333',\n    \n    'stroke-width':1,\n    \n    'fill-opacity':0.2,\n    \n    },\n    \n    },\n    \n    },\n    \n    ],\n    \n    })\n\nsourcetarget\n\n### node-editor\n\n提供节点上文本编辑功能。配置如下：\n\n参数名| 类型| 默认值| 说明  \n---|---|---|---  \nx| number | string| -| 相对于节点的左上角 X 轴的坐标，小数和百分比表示相对位置  \ny| number | string| -| 相对于节点的左上角 Y 轴的坐标，小数和百分比表示相对位置  \nattrs/fontSize| string| `14`| 编辑文本字体大小  \nattrs/color| string| `#000`| 编辑文本字体颜色  \nattrs/fontFamily| string| `Arial, helvetica, sans-serif`| 编辑文本的字体  \nattrs/backgroundColor| string| `#fff`| 编辑区域的背景色  \ngetText| string | `(this: CellView, args: {cell: Cell}) => string`| -| 获取原文本方法，在自定义 `markup` 场景需要自定义 `getText` 方法  \nsetText| string | `(this: CellView, args: {cell: Cell, value: string}) => void`| -| 设置新文本，在自定义 `markup` 场景需要自定义 `setText` 方法  \n  \n#### 注意\n\n需要注意的是，2.8.0 版本后不需要在双击事件中去动态添加工具，也就不需要传入事件参数。\n    \n    \n    // 2.8.0 版本之前使用方式\n    \n    graph.on('node:dblclick',({ node, e })=>{\n    \n      node.addTools({\n    \n        name:'node-editor',\n    \n        args:{\n    \n          event: e,\n    \n    },\n    \n    })\n    \n    })\n    \n    // 2.8.0 版本之后使用方式\n    \n    node.addTools({\n    \n      name:'node-editor',\n    \n    })\n\n还需要注意的是，如果在节点中自定义了 `markup`，往往需要自定义 `getText` 和 `setText` 方法来正确获取和设置编辑文本，这两个配置都支持函数和字符串两种形式，函数比较好理解，字符串其实就是要获取或者设置的文本的属性路径，一般情况下建议使用字符串形式，这样图数据可以完全序列化(因为函数无法序列化)，否则可能会出现渲染画布后文本编辑功能异常，比如：\n    \n    \n    node.addTools({\n    \n      name:'node-editor',\n    \n      args:{\n    \n        getText:'a/b',\n    \n        setText:'c/d',\n    \n    },\n    \n    })\n\n上面配置表示：\n\n  * 获取编辑文本：`node.attr('a/b')`\n  * 设置编辑文本：`node.attr('c/d', value)`\n\n\n\nsourcetargetedge label 1edge label 2\n\n## 自定义工具\n\n### 方式一\n\n继承 `ToolItem` 实现一个工具类，难度较高，要求对 [ToolItem](https://github.com/antvis/X6/blob/master/packages/x6/src/view/tool.ts) 类都有所了解，可以参考上述内置工具的源码，这里不展开叙述。\n    \n    \n    Graph.registerNodeTool('button', Button)\n\n### 方式二\n\n继承已经注册的工具，在继承基础上修改配置。我们在 `ToolItem` 基类上提供了一个静态方法 `define` 来快速实现继承并修改配置。\n    \n    \n    const MyButton = Button.define<Button.Options>({\n    \n      name:'my-btn',\n    \n      markup:...,\n    \n    onClick({ view }){...},\n    \n    })\n    \n    Graph.registerNodeTool('my-btn', MyButton,true)\n\n同时，我们为 `Graph.registerNodeTool` 方法提供了一种快速继承并指定默认选项的实现：\n    \n    \n    Graph.registerNodeTool('my-btn',{\n    \n      inherit:'button',// 基类名称，使用已经注册的工具名称。\n    \n      markup:...,\n    \n      onClick:...,\n    \n    })\n\nsourcetargetbtn\n\n文档贡献者\n\n上一篇\n\n视图\n\n下一篇\n\n边上工具\n"
}
